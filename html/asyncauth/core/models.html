<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>asyncauth.core.models API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>asyncauth.core.models</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import random
import uuid

import aiofiles
import jwt
from captcha.image import ImageCaptcha
from jwt import DecodeError
from sanic.exceptions import ServerError
from sanic.request import Request
from sanic.response import HTTPResponse
from tortoise import fields, Model

from asyncauth.core.config import config
from asyncauth.core.utils import is_expired, best_by, request_ip, random_str, str_to_list


class BaseErrorFactory:
    &#34;&#34;&#34;
    Easily raise or retrieve errors based off of variable values.
    &#34;&#34;&#34;

    def __init__(self, model):
        self.model = model

    def get(self):
        &#34;&#34;&#34;
        Retrieves an error if certain conditions are met.
        :return: error
        &#34;&#34;&#34;
        raise NotImplementedError()

    def throw(self):
        &#34;&#34;&#34;
        Retrieves an error and raises it if certain conditions are met.
        :return: error
        &#34;&#34;&#34;
        error = self.get()
        if error:
            raise error


class AuthError(ServerError):
    &#34;&#34;&#34;
    Base error for all asyncauth related errors.
    &#34;&#34;&#34;

    def __init__(self, message, code):
        super().__init__(message, code)


class BaseModel(Model):
    &#34;&#34;&#34;
    Base asyncauth model that all other models derive from. Some important elements to take in consideration is that
    deletion should be done via the &#39;deleted&#39; variable and filtering it out rather than completely removing it from
    the database. Retrieving asyncauth models should be done via filtering with the &#39;uid&#39; variable rather then the id
    variable.
    &#34;&#34;&#34;

    id = fields.IntField(pk=True)
    account = fields.ForeignKeyField(&#39;models.Account&#39;, null=True)
    uid = fields.UUIDField(unique=True, default=uuid.uuid1, max_length=36)
    date_created = fields.DatetimeField(auto_now_add=True)
    date_updated = fields.DatetimeField(auto_now=True)
    deleted = fields.BooleanField(default=False)

    def json(self):
        raise NotImplementedError()

    class Meta:
        abstract = True

    class NotFoundError(AuthError):
        def __init__(self, message):
            super().__init__(message, 404)

    class DeletedError(AuthError):
        def __init__(self, message):
            super().__init__(message, 404)


class Account(BaseModel):
    &#34;&#34;&#34;
    Contains all identifiable user information such as username, email, and more. All passwords must be hashed when
    being created in the database using the hash_password(str) method in the utils package.
    &#34;&#34;&#34;
    username = fields.CharField(max_length=45)
    email = fields.CharField(unique=True, max_length=45)
    phone = fields.CharField(unique=True, max_length=20, null=True)
    password = fields.BinaryField()
    disabled = fields.BooleanField(default=False)
    verified = fields.BooleanField(default=False)

    class ErrorFactory(BaseErrorFactory):
        def get(self):
            error = None
            if not self.model:
                error = Account.NotFoundError(&#39;This account does not exist.&#39;)
            elif self.model.deleted:
                error = Account.DeletedError(&#39;This account has been permanently deleted.&#39;)
            elif self.model.disabled:
                error = Account.DisabledError()
            elif not self.model.verified:
                error = Account.UnverifiedError()
            return error

    def json(self):
        return {
            &#39;uid&#39;: str(self.uid),
            &#39;date_created&#39;: str(self.date_created),
            &#39;date_updated&#39;: str(self.date_updated),
            &#39;email&#39;: self.email,
            &#39;username&#39;: self.username,
            &#39;disabled&#39;: self.disabled,
            &#39;verified&#39;: self.verified
        }

    @staticmethod
    async def get_client(request: Request):
        &#34;&#34;&#34;
        Retrieves account information from an authentication session found within cookie.
        :param request: Sanic request parameter.
        :return: account
        &#34;&#34;&#34;

        authentication_session = await AuthenticationSession().decode(request)
        return authentication_session.account if authentication_session else None

    class AccountError(AuthError):
        def __init__(self, message, code):
            super().__init__(message, code)

    class ExistsError(AccountError):
        def __init__(self):
            super().__init__(&#39;Account with this email or phone number already exists.&#39;, 409)

    class TooManyCharsError(AccountError):
        def __init__(self):
            super().__init__(&#39;Email, username, or phone number is too long.&#39;, 400)

    class InvalidEmailError(AccountError):
        def __init__(self):
            super().__init__(&#39;Please use a valid email format such as you@mail.com.&#39;, 400)

    class DisabledError(AccountError):
        def __init__(self):
            super().__init__(&#34;This account has been disabled.&#34;, 403)

    class IncorrectPasswordError(AccountError):
        def __init__(self):
            super().__init__(&#39;The password provided is incorrect.&#39;, 401)

    class UnverifiedError(AccountError):
        def __init__(self):
            super().__init__(&#39;Account requires verification.&#39;, 401)


class Session(BaseModel):
    &#34;&#34;&#34;
    Used specifically for client side tracking. For example, an authentication session is stored on the client&#39;s browser
    in order to identify the client. All sessions should be created using the SessionFactory().
    &#34;&#34;&#34;

    expiration_date = fields.DatetimeField(default=best_by, null=True)
    valid = fields.BooleanField(default=True)
    ip = fields.CharField(max_length=16)
    code = fields.CharField(max_length=12, null=True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.cookie = self.__class__.__name__[:4].lower() + &#39;tkn&#39;

    def json(self):
        return {
            &#39;account&#39;: str(self.account.uid),
            &#39;uid&#39;: str(self.uid),
            &#39;date_created&#39;: str(self.date_created),
            &#39;date_updated&#39;: str(self.date_updated),
            &#39;expiration_date&#39;: str(self.expiration_date),
            &#39;valid&#39;: self.valid,
            &#39;ip&#39;: self.ip
        }

    def encode(self, response: HTTPResponse, secure: bool = False, same_site: str = &#39;lax&#39;):
        &#34;&#34;&#34;
        Transforms session into jwt and then is stored in a cookie.

        :param response: Response used to store cookie.

        :param secure: If true, connections must be SSL encrypted (aka https).

        :param same_site: Allows you to declare if your cookie should be restricted to a first-party or same-site context.
        &#34;&#34;&#34;

        payload = {
            &#39;date_created&#39;: str(self.date_created),
            &#39;uid&#39;: str(self.uid),
            &#39;ip&#39;: self.ip
        }
        encoded = jwt.encode(payload, config[&#39;AUTH&#39;][&#39;secret&#39;], algorithm=&#39;HS256&#39;)
        response.cookies[self.cookie] = encoded
        response.cookies[self.cookie][&#39;expires&#39;] = self.expiration_date
        response.cookies[self.cookie][&#39;secure&#39;] = secure
        response.cookies[self.cookie][&#39;samesite&#39;] = same_site

    def decode_raw(self, request: Request) -&gt; dict:
        &#34;&#34;&#34;
        Decodes JWT token in cookie to dict.

        :param request: Sanic request parameter.

        :return: raw
        &#34;&#34;&#34;
        try:
            session = jwt.decode(request.cookies.get(self.cookie), config[&#39;AUTH&#39;][&#39;secret&#39;], algorithms=&#39;HS256&#39;)
            return session
        except DecodeError:
            raise Session.DecodeError()

    async def decode(self, request: Request):
        &#34;&#34;&#34;
        Decodes JWT token in cookie and transforms into session.

        :param request: Sanic request parameter.

        :return: session
        &#34;&#34;&#34;
        decoded = self.decode_raw(request)
        return await self.filter(uid=decoded.get(&#39;uid&#39;)).prefetch_related(&#39;account&#39;).first()

    class Meta:
        abstract = True

    class ErrorFactory(BaseErrorFactory):
        def get(self):
            error = None
            if self.model is None:
                error = Session.NotFoundError(&#39;Session could not be found.&#39;)
            elif not self.model.valid:
                error = Session.InvalidError()
            elif self.model.deleted:
                error = Session.DeletedError(&#39;Session has been deleted.&#39;)
            elif is_expired(self.model.expiration_date):
                error = Session.ExpiredError()
            return error

    class SessionError(AuthError):
        def __init__(self, message, code):
            super().__init__(message, code)

    class DecodeError(SessionError):
        def __init__(self):
            super().__init__(&#39;Session is not available.&#39;, 401)

    class InvalidError(SessionError):
        def __init__(self):
            super().__init__(&#39;Session is invalid.&#39;, 401)

    class ExpiredError(SessionError):
        def __init__(self):
            super().__init__(&#39;Session has expired&#39;, 401)


class SessionFactory:
    &#34;&#34;&#34;
    Prevents human error when creating sessions.
    &#34;&#34;&#34;

    def __init__(self):
        self.path = &#39;./resources/scache&#39;

    async def generate_session_codes(self):
        &#34;&#34;&#34;
        Generates up to 100 verification code variations in a codes.txt file
        &#34;&#34;&#34;
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            async with aiofiles.open(self.path + &#39;/codes.txt&#39;, mode=&#34;w&#34;) as f:
                image = ImageCaptcha(fonts=str_to_list(config[&#39;AUTH&#39;][&#39;captcha_fonts&#39;]))
                for i in range(100):
                    code = random_str(12)
                    await f.write(code + &#39; &#39;)
                    image.write(code, self.path + &#39;/&#39; + code + &#39;.png&#39;)

    async def _get_random_code(self):
        &#34;&#34;&#34;
        Retrieves a random code from a codes.txt file

        :return: code
        &#34;&#34;&#34;
        async with aiofiles.open(self.path + &#39;/codes.txt&#39;, mode=&#39;r&#39;) as f:
            codes = await f.read()
            return random.choice(codes.split())

    async def get(self, session_type: str, request: Request, account: Account = None):
        &#34;&#34;&#34;
        :param session_type: The type of session being retrieved. Available types are: captcha, verification,
        authentication, and recovery.

        :param request: Sanic request parameter.

        :param account:

        :return:
        &#34;&#34;&#34;
        await self.generate_session_codes()
        account = await Account.get_client(request) if None else account
        code = await self._get_random_code()
        if session_type == &#39;captcha&#39;:
            return await CaptchaSession.create(ip=request_ip(request), code=code.lower()[:5])
        elif session_type == &#39;verification&#39;:
            return await VerificationSession.create(code=code, ip=request_ip(request), account=account)
        elif session_type == &#39;authentication&#39;:
            return await AuthenticationSession.create(account=account, ip=request_ip(request),
                                                      expiration_date=best_by(30))
        elif session_type == &#39;recovery&#39;:
            return await RecoverySession.create(account=account, ip=request_ip(request), code=code)
        else:
            raise ValueError


class VerificationSession(Session):
    &#34;&#34;&#34;
    Verifies an account via emailing or texting a code.
    &#34;&#34;&#34;
    class VerificationCodeError(Session.SessionError):
        def __init__(self):
            super().__init__(&#39;Your verification attempt was incorrect&#39;, 403)


class RecoverySession(VerificationSession):
    &#34;&#34;&#34;
    Verifies password recovery attempts via emailing or texting a code.
    &#34;&#34;&#34;
    pass


class CaptchaSession(Session):
    &#34;&#34;&#34;
    Validates an client as human by forcing a user to correctly enter a captcha challenge.
    &#34;&#34;&#34;

    class IncorrectCaptchaError(Session.SessionError):
        def __init__(self):
            super().__init__(&#39;Your captcha attempt was incorrect.&#39;, 403)

    async def captcha_img(self, request):
        &#34;&#34;&#34;
        Retrieves image path of client captcha.

        :return: captcha_img_path
        &#34;&#34;&#34;
        decoded_captcha_session = self.decode_raw(request)
        captcha_session = await CaptchaSession.filter(uid=decoded_captcha_session.get(&#39;uid&#39;)).first()
        return &#39;./resources/scache/&#39; + captcha_session.code + &#39;.png&#39;


class AuthenticationSession(Session):
    class UnknownLocationError(Session.SessionError):
        def __init__(self):
            super().__init__(&#39;Attempting to authenticate in an unknown location.&#39;, 403)

    async def verify_location(self, request):
        &#34;&#34;&#34;
        Checks if client using session is in a known location (ip address). Prevents cookie jacking.

        :raises UnknownLocationError:
        &#34;&#34;&#34;

        if not await AuthenticationSession.filter(ip=request_ip(request), account=self.account).exists():
            raise AuthenticationSession.UnknownLocationError()


class Role(BaseModel):
    &#34;&#34;&#34;
    Assigned to an account to authorize an action. Used for role based authorization.
    &#34;&#34;&#34;
    name = fields.CharField(max_length=45)

    def json(self):
        return {
            &#39;uid&#39;: str(self.uid),
            &#39;date_created&#39;: str(self.date_created),
            &#39;date_updated&#39;: str(self.date_updated),
            &#39;name&#39;: self.name,
        }

    class InsufficientRoleError(AuthError):
        def __init__(self):
            super().__init__(&#39;You do not have the required role for this action.&#39;, 403)


class Permission(BaseModel):
    &#34;&#34;&#34;
    Assigned to an account to authorize an action. Used for wildcard based authorization.
    &#34;&#34;&#34;
    wildcard = fields.CharField(max_length=45)

    def json(self):
        return {
            &#39;uid&#39;: str(self.uid),
            &#39;date_created&#39;: str(self.date_created),
            &#39;date_updated&#39;: str(self.date_updated),
            &#39;wildcard&#39;: self.wildcard,
        }

    class InsufficientPermissionError(AuthError):
        def __init__(self):
            super().__init__(&#39;You do not have the required permissions for this action.&#39;, 403)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="asyncauth.core.models.Account"><code class="flex name class">
<span>class <span class="ident">Account</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains all identifiable user information such as username, email, and more. All passwords must be hashed when
being created in the database using the hash_password(str) method in the utils package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Account(BaseModel):
    &#34;&#34;&#34;
    Contains all identifiable user information such as username, email, and more. All passwords must be hashed when
    being created in the database using the hash_password(str) method in the utils package.
    &#34;&#34;&#34;
    username = fields.CharField(max_length=45)
    email = fields.CharField(unique=True, max_length=45)
    phone = fields.CharField(unique=True, max_length=20, null=True)
    password = fields.BinaryField()
    disabled = fields.BooleanField(default=False)
    verified = fields.BooleanField(default=False)

    class ErrorFactory(BaseErrorFactory):
        def get(self):
            error = None
            if not self.model:
                error = Account.NotFoundError(&#39;This account does not exist.&#39;)
            elif self.model.deleted:
                error = Account.DeletedError(&#39;This account has been permanently deleted.&#39;)
            elif self.model.disabled:
                error = Account.DisabledError()
            elif not self.model.verified:
                error = Account.UnverifiedError()
            return error

    def json(self):
        return {
            &#39;uid&#39;: str(self.uid),
            &#39;date_created&#39;: str(self.date_created),
            &#39;date_updated&#39;: str(self.date_updated),
            &#39;email&#39;: self.email,
            &#39;username&#39;: self.username,
            &#39;disabled&#39;: self.disabled,
            &#39;verified&#39;: self.verified
        }

    @staticmethod
    async def get_client(request: Request):
        &#34;&#34;&#34;
        Retrieves account information from an authentication session found within cookie.
        :param request: Sanic request parameter.
        :return: account
        &#34;&#34;&#34;

        authentication_session = await AuthenticationSession().decode(request)
        return authentication_session.account if authentication_session else None

    class AccountError(AuthError):
        def __init__(self, message, code):
            super().__init__(message, code)

    class ExistsError(AccountError):
        def __init__(self):
            super().__init__(&#39;Account with this email or phone number already exists.&#39;, 409)

    class TooManyCharsError(AccountError):
        def __init__(self):
            super().__init__(&#39;Email, username, or phone number is too long.&#39;, 400)

    class InvalidEmailError(AccountError):
        def __init__(self):
            super().__init__(&#39;Please use a valid email format such as you@mail.com.&#39;, 400)

    class DisabledError(AccountError):
        def __init__(self):
            super().__init__(&#34;This account has been disabled.&#34;, 403)

    class IncorrectPasswordError(AccountError):
        def __init__(self):
            super().__init__(&#39;The password provided is incorrect.&#39;, 401)

    class UnverifiedError(AccountError):
        def __init__(self):
            super().__init__(&#39;Account requires verification.&#39;, 401)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></li>
<li>tortoise.models.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asyncauth.core.models.Account.AccountError"><code class="name">var <span class="ident">AccountError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Account.DisabledError"><code class="name">var <span class="ident">DisabledError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Account.ErrorFactory"><code class="name">var <span class="ident">ErrorFactory</span></code></dt>
<dd>
<div class="desc"><p>Easily raise or retrieve errors based off of variable values.</p></div>
</dd>
<dt id="asyncauth.core.models.Account.ExistsError"><code class="name">var <span class="ident">ExistsError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Account.IncorrectPasswordError"><code class="name">var <span class="ident">IncorrectPasswordError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Account.InvalidEmailError"><code class="name">var <span class="ident">InvalidEmailError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Account.TooManyCharsError"><code class="name">var <span class="ident">TooManyCharsError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Account.UnverifiedError"><code class="name">var <span class="ident">UnverifiedError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="asyncauth.core.models.Account.get_client"><code class="name flex">
<span>async def <span class="ident">get_client</span></span>(<span>request: sanic.request.Request)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves account information from an authentication session found within cookie.
:param request: Sanic request parameter.
:return: account</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def get_client(request: Request):
    &#34;&#34;&#34;
    Retrieves account information from an authentication session found within cookie.
    :param request: Sanic request parameter.
    :return: account
    &#34;&#34;&#34;

    authentication_session = await AuthenticationSession().decode(request)
    return authentication_session.account if authentication_session else None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.Account.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
    return {
        &#39;uid&#39;: str(self.uid),
        &#39;date_created&#39;: str(self.date_created),
        &#39;date_updated&#39;: str(self.date_updated),
        &#39;email&#39;: self.email,
        &#39;username&#39;: self.username,
        &#39;disabled&#39;: self.disabled,
        &#39;verified&#39;: self.verified
    }</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></b></code>:
<ul class="hlist">
<li><code><a title="asyncauth.core.models.BaseModel.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.BaseModel.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="asyncauth.core.models.AuthError"><code class="flex name class">
<span>class <span class="ident">AuthError</span></span>
<span>(</span><span>message, code)</span>
</code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthError(ServerError):
    &#34;&#34;&#34;
    Base error for all asyncauth related errors.
    &#34;&#34;&#34;

    def __init__(self, message, code):
        super().__init__(message, code)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sanic.exceptions.ServerError</li>
<li>sanic.exceptions.SanicException</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.Account.AccountError" href="#asyncauth.core.models.Account.AccountError">Account.AccountError</a></li>
<li><a title="asyncauth.core.models.BaseModel.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">BaseModel.DeletedError</a></li>
<li><a title="asyncauth.core.models.BaseModel.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">BaseModel.NotFoundError</a></li>
<li><a title="asyncauth.core.models.Permission.InsufficientPermissionError" href="#asyncauth.core.models.Permission.InsufficientPermissionError">Permission.InsufficientPermissionError</a></li>
<li><a title="asyncauth.core.models.Role.InsufficientRoleError" href="#asyncauth.core.models.Role.InsufficientRoleError">Role.InsufficientRoleError</a></li>
<li><a title="asyncauth.core.models.Session.SessionError" href="#asyncauth.core.models.Session.SessionError">Session.SessionError</a></li>
</ul>
</dd>
<dt id="asyncauth.core.models.AuthenticationSession"><code class="flex name class">
<span>class <span class="ident">AuthenticationSession</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Used specifically for client side tracking. For example, an authentication session is stored on the client's browser
in order to identify the client. All sessions should be created using the SessionFactory().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthenticationSession(Session):
    class UnknownLocationError(Session.SessionError):
        def __init__(self):
            super().__init__(&#39;Attempting to authenticate in an unknown location.&#39;, 403)

    async def verify_location(self, request):
        &#34;&#34;&#34;
        Checks if client using session is in a known location (ip address). Prevents cookie jacking.

        :raises UnknownLocationError:
        &#34;&#34;&#34;

        if not await AuthenticationSession.filter(ip=request_ip(request), account=self.account).exists():
            raise AuthenticationSession.UnknownLocationError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></li>
<li><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></li>
<li>tortoise.models.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asyncauth.core.models.AuthenticationSession.UnknownLocationError"><code class="name">var <span class="ident">UnknownLocationError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.AuthenticationSession.verify_location"><code class="name flex">
<span>async def <span class="ident">verify_location</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if client using session is in a known location (ip address). Prevents cookie jacking.</p>
<p>:raises UnknownLocationError:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def verify_location(self, request):
    &#34;&#34;&#34;
    Checks if client using session is in a known location (ip address). Prevents cookie jacking.

    :raises UnknownLocationError:
    &#34;&#34;&#34;

    if not await AuthenticationSession.filter(ip=request_ip(request), account=self.account).exists():
        raise AuthenticationSession.UnknownLocationError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></b></code>:
<ul class="hlist">
<li><code><a title="asyncauth.core.models.Session.DecodeError" href="#asyncauth.core.models.Session.DecodeError">DecodeError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.ErrorFactory" href="#asyncauth.core.models.Session.ErrorFactory">ErrorFactory</a></code></li>
<li><code><a title="asyncauth.core.models.Session.ExpiredError" href="#asyncauth.core.models.Session.ExpiredError">ExpiredError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.InvalidError" href="#asyncauth.core.models.Session.InvalidError">InvalidError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.SessionError" href="#asyncauth.core.models.Session.SessionError">SessionError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.decode" href="#asyncauth.core.models.Session.decode">decode</a></code></li>
<li><code><a title="asyncauth.core.models.Session.decode_raw" href="#asyncauth.core.models.Session.decode_raw">decode_raw</a></code></li>
<li><code><a title="asyncauth.core.models.Session.encode" href="#asyncauth.core.models.Session.encode">encode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="asyncauth.core.models.BaseErrorFactory"><code class="flex name class">
<span>class <span class="ident">BaseErrorFactory</span></span>
<span>(</span><span>model)</span>
</code></dt>
<dd>
<div class="desc"><p>Easily raise or retrieve errors based off of variable values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseErrorFactory:
    &#34;&#34;&#34;
    Easily raise or retrieve errors based off of variable values.
    &#34;&#34;&#34;

    def __init__(self, model):
        self.model = model

    def get(self):
        &#34;&#34;&#34;
        Retrieves an error if certain conditions are met.
        :return: error
        &#34;&#34;&#34;
        raise NotImplementedError()

    def throw(self):
        &#34;&#34;&#34;
        Retrieves an error and raises it if certain conditions are met.
        :return: error
        &#34;&#34;&#34;
        error = self.get()
        if error:
            raise error</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.Account.ErrorFactory" href="#asyncauth.core.models.Account.ErrorFactory">Account.ErrorFactory</a></li>
<li><a title="asyncauth.core.models.Session.ErrorFactory" href="#asyncauth.core.models.Session.ErrorFactory">Session.ErrorFactory</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.BaseErrorFactory.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves an error if certain conditions are met.
:return: error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    &#34;&#34;&#34;
    Retrieves an error if certain conditions are met.
    :return: error
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="asyncauth.core.models.BaseErrorFactory.throw"><code class="name flex">
<span>def <span class="ident">throw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves an error and raises it if certain conditions are met.
:return: error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def throw(self):
    &#34;&#34;&#34;
    Retrieves an error and raises it if certain conditions are met.
    :return: error
    &#34;&#34;&#34;
    error = self.get()
    if error:
        raise error</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="asyncauth.core.models.BaseModel"><code class="flex name class">
<span>class <span class="ident">BaseModel</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Base asyncauth model that all other models derive from. Some important elements to take in consideration is that
deletion should be done via the 'deleted' variable and filtering it out rather than completely removing it from
the database. Retrieving asyncauth models should be done via filtering with the 'uid' variable rather then the id
variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseModel(Model):
    &#34;&#34;&#34;
    Base asyncauth model that all other models derive from. Some important elements to take in consideration is that
    deletion should be done via the &#39;deleted&#39; variable and filtering it out rather than completely removing it from
    the database. Retrieving asyncauth models should be done via filtering with the &#39;uid&#39; variable rather then the id
    variable.
    &#34;&#34;&#34;

    id = fields.IntField(pk=True)
    account = fields.ForeignKeyField(&#39;models.Account&#39;, null=True)
    uid = fields.UUIDField(unique=True, default=uuid.uuid1, max_length=36)
    date_created = fields.DatetimeField(auto_now_add=True)
    date_updated = fields.DatetimeField(auto_now=True)
    deleted = fields.BooleanField(default=False)

    def json(self):
        raise NotImplementedError()

    class Meta:
        abstract = True

    class NotFoundError(AuthError):
        def __init__(self, message):
            super().__init__(message, 404)

    class DeletedError(AuthError):
        def __init__(self, message):
            super().__init__(message, 404)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tortoise.models.Model</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.Account" href="#asyncauth.core.models.Account">Account</a></li>
<li><a title="asyncauth.core.models.Permission" href="#asyncauth.core.models.Permission">Permission</a></li>
<li><a title="asyncauth.core.models.Role" href="#asyncauth.core.models.Role">Role</a></li>
<li><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asyncauth.core.models.BaseModel.DeletedError"><code class="name">var <span class="ident">DeletedError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.BaseModel.Meta"><code class="name">var <span class="ident">Meta</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="asyncauth.core.models.BaseModel.NotFoundError"><code class="name">var <span class="ident">NotFoundError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.BaseModel.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="asyncauth.core.models.CaptchaSession"><code class="flex name class">
<span>class <span class="ident">CaptchaSession</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Validates an client as human by forcing a user to correctly enter a captcha challenge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CaptchaSession(Session):
    &#34;&#34;&#34;
    Validates an client as human by forcing a user to correctly enter a captcha challenge.
    &#34;&#34;&#34;

    class IncorrectCaptchaError(Session.SessionError):
        def __init__(self):
            super().__init__(&#39;Your captcha attempt was incorrect.&#39;, 403)

    async def captcha_img(self, request):
        &#34;&#34;&#34;
        Retrieves image path of client captcha.

        :return: captcha_img_path
        &#34;&#34;&#34;
        decoded_captcha_session = self.decode_raw(request)
        captcha_session = await CaptchaSession.filter(uid=decoded_captcha_session.get(&#39;uid&#39;)).first()
        return &#39;./resources/scache/&#39; + captcha_session.code + &#39;.png&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></li>
<li><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></li>
<li>tortoise.models.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asyncauth.core.models.CaptchaSession.IncorrectCaptchaError"><code class="name">var <span class="ident">IncorrectCaptchaError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.CaptchaSession.captcha_img"><code class="name flex">
<span>async def <span class="ident">captcha_img</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves image path of client captcha.</p>
<p>:return: captcha_img_path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def captcha_img(self, request):
    &#34;&#34;&#34;
    Retrieves image path of client captcha.

    :return: captcha_img_path
    &#34;&#34;&#34;
    decoded_captcha_session = self.decode_raw(request)
    captcha_session = await CaptchaSession.filter(uid=decoded_captcha_session.get(&#39;uid&#39;)).first()
    return &#39;./resources/scache/&#39; + captcha_session.code + &#39;.png&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></b></code>:
<ul class="hlist">
<li><code><a title="asyncauth.core.models.Session.DecodeError" href="#asyncauth.core.models.Session.DecodeError">DecodeError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.ErrorFactory" href="#asyncauth.core.models.Session.ErrorFactory">ErrorFactory</a></code></li>
<li><code><a title="asyncauth.core.models.Session.ExpiredError" href="#asyncauth.core.models.Session.ExpiredError">ExpiredError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.InvalidError" href="#asyncauth.core.models.Session.InvalidError">InvalidError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.SessionError" href="#asyncauth.core.models.Session.SessionError">SessionError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.decode" href="#asyncauth.core.models.Session.decode">decode</a></code></li>
<li><code><a title="asyncauth.core.models.Session.decode_raw" href="#asyncauth.core.models.Session.decode_raw">decode_raw</a></code></li>
<li><code><a title="asyncauth.core.models.Session.encode" href="#asyncauth.core.models.Session.encode">encode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="asyncauth.core.models.Permission"><code class="flex name class">
<span>class <span class="ident">Permission</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigned to an account to authorize an action. Used for wildcard based authorization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Permission(BaseModel):
    &#34;&#34;&#34;
    Assigned to an account to authorize an action. Used for wildcard based authorization.
    &#34;&#34;&#34;
    wildcard = fields.CharField(max_length=45)

    def json(self):
        return {
            &#39;uid&#39;: str(self.uid),
            &#39;date_created&#39;: str(self.date_created),
            &#39;date_updated&#39;: str(self.date_updated),
            &#39;wildcard&#39;: self.wildcard,
        }

    class InsufficientPermissionError(AuthError):
        def __init__(self):
            super().__init__(&#39;You do not have the required permissions for this action.&#39;, 403)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></li>
<li>tortoise.models.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asyncauth.core.models.Permission.InsufficientPermissionError"><code class="name">var <span class="ident">InsufficientPermissionError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.Permission.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
    return {
        &#39;uid&#39;: str(self.uid),
        &#39;date_created&#39;: str(self.date_created),
        &#39;date_updated&#39;: str(self.date_updated),
        &#39;wildcard&#39;: self.wildcard,
    }</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></b></code>:
<ul class="hlist">
<li><code><a title="asyncauth.core.models.BaseModel.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.BaseModel.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="asyncauth.core.models.RecoverySession"><code class="flex name class">
<span>class <span class="ident">RecoverySession</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies password recovery attempts via emailing or texting a code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecoverySession(VerificationSession):
    &#34;&#34;&#34;
    Verifies password recovery attempts via emailing or texting a code.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.VerificationSession" href="#asyncauth.core.models.VerificationSession">VerificationSession</a></li>
<li><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></li>
<li><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></li>
<li>tortoise.models.Model</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="asyncauth.core.models.VerificationSession" href="#asyncauth.core.models.VerificationSession">VerificationSession</a></b></code>:
<ul class="hlist">
<li><code><a title="asyncauth.core.models.VerificationSession.DecodeError" href="#asyncauth.core.models.Session.DecodeError">DecodeError</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.ErrorFactory" href="#asyncauth.core.models.Session.ErrorFactory">ErrorFactory</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.ExpiredError" href="#asyncauth.core.models.Session.ExpiredError">ExpiredError</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.InvalidError" href="#asyncauth.core.models.Session.InvalidError">InvalidError</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.SessionError" href="#asyncauth.core.models.Session.SessionError">SessionError</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.VerificationCodeError" href="#asyncauth.core.models.VerificationSession.VerificationCodeError">VerificationCodeError</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.decode" href="#asyncauth.core.models.Session.decode">decode</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.decode_raw" href="#asyncauth.core.models.Session.decode_raw">decode_raw</a></code></li>
<li><code><a title="asyncauth.core.models.VerificationSession.encode" href="#asyncauth.core.models.Session.encode">encode</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="asyncauth.core.models.Role"><code class="flex name class">
<span>class <span class="ident">Role</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigned to an account to authorize an action. Used for role based authorization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Role(BaseModel):
    &#34;&#34;&#34;
    Assigned to an account to authorize an action. Used for role based authorization.
    &#34;&#34;&#34;
    name = fields.CharField(max_length=45)

    def json(self):
        return {
            &#39;uid&#39;: str(self.uid),
            &#39;date_created&#39;: str(self.date_created),
            &#39;date_updated&#39;: str(self.date_updated),
            &#39;name&#39;: self.name,
        }

    class InsufficientRoleError(AuthError):
        def __init__(self):
            super().__init__(&#39;You do not have the required role for this action.&#39;, 403)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></li>
<li>tortoise.models.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asyncauth.core.models.Role.InsufficientRoleError"><code class="name">var <span class="ident">InsufficientRoleError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.Role.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
    return {
        &#39;uid&#39;: str(self.uid),
        &#39;date_created&#39;: str(self.date_created),
        &#39;date_updated&#39;: str(self.date_updated),
        &#39;name&#39;: self.name,
    }</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></b></code>:
<ul class="hlist">
<li><code><a title="asyncauth.core.models.BaseModel.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.BaseModel.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="asyncauth.core.models.Session"><code class="flex name class">
<span>class <span class="ident">Session</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Used specifically for client side tracking. For example, an authentication session is stored on the client's browser
in order to identify the client. All sessions should be created using the SessionFactory().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Session(BaseModel):
    &#34;&#34;&#34;
    Used specifically for client side tracking. For example, an authentication session is stored on the client&#39;s browser
    in order to identify the client. All sessions should be created using the SessionFactory().
    &#34;&#34;&#34;

    expiration_date = fields.DatetimeField(default=best_by, null=True)
    valid = fields.BooleanField(default=True)
    ip = fields.CharField(max_length=16)
    code = fields.CharField(max_length=12, null=True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.cookie = self.__class__.__name__[:4].lower() + &#39;tkn&#39;

    def json(self):
        return {
            &#39;account&#39;: str(self.account.uid),
            &#39;uid&#39;: str(self.uid),
            &#39;date_created&#39;: str(self.date_created),
            &#39;date_updated&#39;: str(self.date_updated),
            &#39;expiration_date&#39;: str(self.expiration_date),
            &#39;valid&#39;: self.valid,
            &#39;ip&#39;: self.ip
        }

    def encode(self, response: HTTPResponse, secure: bool = False, same_site: str = &#39;lax&#39;):
        &#34;&#34;&#34;
        Transforms session into jwt and then is stored in a cookie.

        :param response: Response used to store cookie.

        :param secure: If true, connections must be SSL encrypted (aka https).

        :param same_site: Allows you to declare if your cookie should be restricted to a first-party or same-site context.
        &#34;&#34;&#34;

        payload = {
            &#39;date_created&#39;: str(self.date_created),
            &#39;uid&#39;: str(self.uid),
            &#39;ip&#39;: self.ip
        }
        encoded = jwt.encode(payload, config[&#39;AUTH&#39;][&#39;secret&#39;], algorithm=&#39;HS256&#39;)
        response.cookies[self.cookie] = encoded
        response.cookies[self.cookie][&#39;expires&#39;] = self.expiration_date
        response.cookies[self.cookie][&#39;secure&#39;] = secure
        response.cookies[self.cookie][&#39;samesite&#39;] = same_site

    def decode_raw(self, request: Request) -&gt; dict:
        &#34;&#34;&#34;
        Decodes JWT token in cookie to dict.

        :param request: Sanic request parameter.

        :return: raw
        &#34;&#34;&#34;
        try:
            session = jwt.decode(request.cookies.get(self.cookie), config[&#39;AUTH&#39;][&#39;secret&#39;], algorithms=&#39;HS256&#39;)
            return session
        except DecodeError:
            raise Session.DecodeError()

    async def decode(self, request: Request):
        &#34;&#34;&#34;
        Decodes JWT token in cookie and transforms into session.

        :param request: Sanic request parameter.

        :return: session
        &#34;&#34;&#34;
        decoded = self.decode_raw(request)
        return await self.filter(uid=decoded.get(&#39;uid&#39;)).prefetch_related(&#39;account&#39;).first()

    class Meta:
        abstract = True

    class ErrorFactory(BaseErrorFactory):
        def get(self):
            error = None
            if self.model is None:
                error = Session.NotFoundError(&#39;Session could not be found.&#39;)
            elif not self.model.valid:
                error = Session.InvalidError()
            elif self.model.deleted:
                error = Session.DeletedError(&#39;Session has been deleted.&#39;)
            elif is_expired(self.model.expiration_date):
                error = Session.ExpiredError()
            return error

    class SessionError(AuthError):
        def __init__(self, message, code):
            super().__init__(message, code)

    class DecodeError(SessionError):
        def __init__(self):
            super().__init__(&#39;Session is not available.&#39;, 401)

    class InvalidError(SessionError):
        def __init__(self):
            super().__init__(&#39;Session is invalid.&#39;, 401)

    class ExpiredError(SessionError):
        def __init__(self):
            super().__init__(&#39;Session has expired&#39;, 401)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></li>
<li>tortoise.models.Model</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.AuthenticationSession" href="#asyncauth.core.models.AuthenticationSession">AuthenticationSession</a></li>
<li><a title="asyncauth.core.models.CaptchaSession" href="#asyncauth.core.models.CaptchaSession">CaptchaSession</a></li>
<li><a title="asyncauth.core.models.VerificationSession" href="#asyncauth.core.models.VerificationSession">VerificationSession</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asyncauth.core.models.Session.DecodeError"><code class="name">var <span class="ident">DecodeError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Session.ErrorFactory"><code class="name">var <span class="ident">ErrorFactory</span></code></dt>
<dd>
<div class="desc"><p>Easily raise or retrieve errors based off of variable values.</p></div>
</dd>
<dt id="asyncauth.core.models.Session.ExpiredError"><code class="name">var <span class="ident">ExpiredError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Session.InvalidError"><code class="name">var <span class="ident">InvalidError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
<dt id="asyncauth.core.models.Session.Meta"><code class="name">var <span class="ident">Meta</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="asyncauth.core.models.Session.SessionError"><code class="name">var <span class="ident">SessionError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.Session.decode"><code class="name flex">
<span>async def <span class="ident">decode</span></span>(<span>self, request: sanic.request.Request)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes JWT token in cookie and transforms into session.</p>
<p>:param request: Sanic request parameter.</p>
<p>:return: session</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def decode(self, request: Request):
    &#34;&#34;&#34;
    Decodes JWT token in cookie and transforms into session.

    :param request: Sanic request parameter.

    :return: session
    &#34;&#34;&#34;
    decoded = self.decode_raw(request)
    return await self.filter(uid=decoded.get(&#39;uid&#39;)).prefetch_related(&#39;account&#39;).first()</code></pre>
</details>
</dd>
<dt id="asyncauth.core.models.Session.decode_raw"><code class="name flex">
<span>def <span class="ident">decode_raw</span></span>(<span>self, request: sanic.request.Request) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes JWT token in cookie to dict.</p>
<p>:param request: Sanic request parameter.</p>
<p>:return: raw</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_raw(self, request: Request) -&gt; dict:
    &#34;&#34;&#34;
    Decodes JWT token in cookie to dict.

    :param request: Sanic request parameter.

    :return: raw
    &#34;&#34;&#34;
    try:
        session = jwt.decode(request.cookies.get(self.cookie), config[&#39;AUTH&#39;][&#39;secret&#39;], algorithms=&#39;HS256&#39;)
        return session
    except DecodeError:
        raise Session.DecodeError()</code></pre>
</details>
</dd>
<dt id="asyncauth.core.models.Session.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, response: sanic.response.HTTPResponse, secure: bool = False, same_site: str = 'lax')</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms session into jwt and then is stored in a cookie.</p>
<p>:param response: Response used to store cookie.</p>
<p>:param secure: If true, connections must be SSL encrypted (aka https).</p>
<p>:param same_site: Allows you to declare if your cookie should be restricted to a first-party or same-site context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, response: HTTPResponse, secure: bool = False, same_site: str = &#39;lax&#39;):
    &#34;&#34;&#34;
    Transforms session into jwt and then is stored in a cookie.

    :param response: Response used to store cookie.

    :param secure: If true, connections must be SSL encrypted (aka https).

    :param same_site: Allows you to declare if your cookie should be restricted to a first-party or same-site context.
    &#34;&#34;&#34;

    payload = {
        &#39;date_created&#39;: str(self.date_created),
        &#39;uid&#39;: str(self.uid),
        &#39;ip&#39;: self.ip
    }
    encoded = jwt.encode(payload, config[&#39;AUTH&#39;][&#39;secret&#39;], algorithm=&#39;HS256&#39;)
    response.cookies[self.cookie] = encoded
    response.cookies[self.cookie][&#39;expires&#39;] = self.expiration_date
    response.cookies[self.cookie][&#39;secure&#39;] = secure
    response.cookies[self.cookie][&#39;samesite&#39;] = same_site</code></pre>
</details>
</dd>
<dt id="asyncauth.core.models.Session.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
    return {
        &#39;account&#39;: str(self.account.uid),
        &#39;uid&#39;: str(self.uid),
        &#39;date_created&#39;: str(self.date_created),
        &#39;date_updated&#39;: str(self.date_updated),
        &#39;expiration_date&#39;: str(self.expiration_date),
        &#39;valid&#39;: self.valid,
        &#39;ip&#39;: self.ip
    }</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></b></code>:
<ul class="hlist">
<li><code><a title="asyncauth.core.models.BaseModel.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.BaseModel.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="asyncauth.core.models.SessionFactory"><code class="flex name class">
<span>class <span class="ident">SessionFactory</span></span>
</code></dt>
<dd>
<div class="desc"><p>Prevents human error when creating sessions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionFactory:
    &#34;&#34;&#34;
    Prevents human error when creating sessions.
    &#34;&#34;&#34;

    def __init__(self):
        self.path = &#39;./resources/scache&#39;

    async def generate_session_codes(self):
        &#34;&#34;&#34;
        Generates up to 100 verification code variations in a codes.txt file
        &#34;&#34;&#34;
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            async with aiofiles.open(self.path + &#39;/codes.txt&#39;, mode=&#34;w&#34;) as f:
                image = ImageCaptcha(fonts=str_to_list(config[&#39;AUTH&#39;][&#39;captcha_fonts&#39;]))
                for i in range(100):
                    code = random_str(12)
                    await f.write(code + &#39; &#39;)
                    image.write(code, self.path + &#39;/&#39; + code + &#39;.png&#39;)

    async def _get_random_code(self):
        &#34;&#34;&#34;
        Retrieves a random code from a codes.txt file

        :return: code
        &#34;&#34;&#34;
        async with aiofiles.open(self.path + &#39;/codes.txt&#39;, mode=&#39;r&#39;) as f:
            codes = await f.read()
            return random.choice(codes.split())

    async def get(self, session_type: str, request: Request, account: Account = None):
        &#34;&#34;&#34;
        :param session_type: The type of session being retrieved. Available types are: captcha, verification,
        authentication, and recovery.

        :param request: Sanic request parameter.

        :param account:

        :return:
        &#34;&#34;&#34;
        await self.generate_session_codes()
        account = await Account.get_client(request) if None else account
        code = await self._get_random_code()
        if session_type == &#39;captcha&#39;:
            return await CaptchaSession.create(ip=request_ip(request), code=code.lower()[:5])
        elif session_type == &#39;verification&#39;:
            return await VerificationSession.create(code=code, ip=request_ip(request), account=account)
        elif session_type == &#39;authentication&#39;:
            return await AuthenticationSession.create(account=account, ip=request_ip(request),
                                                      expiration_date=best_by(30))
        elif session_type == &#39;recovery&#39;:
            return await RecoverySession.create(account=account, ip=request_ip(request), code=code)
        else:
            raise ValueError</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="asyncauth.core.models.SessionFactory.generate_session_codes"><code class="name flex">
<span>async def <span class="ident">generate_session_codes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates up to 100 verification code variations in a codes.txt file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def generate_session_codes(self):
    &#34;&#34;&#34;
    Generates up to 100 verification code variations in a codes.txt file
    &#34;&#34;&#34;
    if not os.path.exists(self.path):
        os.makedirs(self.path)
        async with aiofiles.open(self.path + &#39;/codes.txt&#39;, mode=&#34;w&#34;) as f:
            image = ImageCaptcha(fonts=str_to_list(config[&#39;AUTH&#39;][&#39;captcha_fonts&#39;]))
            for i in range(100):
                code = random_str(12)
                await f.write(code + &#39; &#39;)
                image.write(code, self.path + &#39;/&#39; + code + &#39;.png&#39;)</code></pre>
</details>
</dd>
<dt id="asyncauth.core.models.SessionFactory.get"><code class="name flex">
<span>async def <span class="ident">get</span></span>(<span>self, session_type: str, request: sanic.request.Request, account: <a title="asyncauth.core.models.Account" href="#asyncauth.core.models.Account">Account</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>:param session_type: The type of session being retrieved. Available types are: captcha, verification,
authentication, and recovery.</p>
<p>:param request: Sanic request parameter.</p>
<p>:param account:</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get(self, session_type: str, request: Request, account: Account = None):
    &#34;&#34;&#34;
    :param session_type: The type of session being retrieved. Available types are: captcha, verification,
    authentication, and recovery.

    :param request: Sanic request parameter.

    :param account:

    :return:
    &#34;&#34;&#34;
    await self.generate_session_codes()
    account = await Account.get_client(request) if None else account
    code = await self._get_random_code()
    if session_type == &#39;captcha&#39;:
        return await CaptchaSession.create(ip=request_ip(request), code=code.lower()[:5])
    elif session_type == &#39;verification&#39;:
        return await VerificationSession.create(code=code, ip=request_ip(request), account=account)
    elif session_type == &#39;authentication&#39;:
        return await AuthenticationSession.create(account=account, ip=request_ip(request),
                                                  expiration_date=best_by(30))
    elif session_type == &#39;recovery&#39;:
        return await RecoverySession.create(account=account, ip=request_ip(request), code=code)
    else:
        raise ValueError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="asyncauth.core.models.VerificationSession"><code class="flex name class">
<span>class <span class="ident">VerificationSession</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies an account via emailing or texting a code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VerificationSession(Session):
    &#34;&#34;&#34;
    Verifies an account via emailing or texting a code.
    &#34;&#34;&#34;
    class VerificationCodeError(Session.SessionError):
        def __init__(self):
            super().__init__(&#39;Your verification attempt was incorrect&#39;, 403)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></li>
<li><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></li>
<li>tortoise.models.Model</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="asyncauth.core.models.RecoverySession" href="#asyncauth.core.models.RecoverySession">RecoverySession</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asyncauth.core.models.VerificationSession.VerificationCodeError"><code class="name">var <span class="ident">VerificationCodeError</span></code></dt>
<dd>
<div class="desc"><p>Base error for all asyncauth related errors.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></b></code>:
<ul class="hlist">
<li><code><a title="asyncauth.core.models.Session.DecodeError" href="#asyncauth.core.models.Session.DecodeError">DecodeError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.ErrorFactory" href="#asyncauth.core.models.Session.ErrorFactory">ErrorFactory</a></code></li>
<li><code><a title="asyncauth.core.models.Session.ExpiredError" href="#asyncauth.core.models.Session.ExpiredError">ExpiredError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.InvalidError" href="#asyncauth.core.models.Session.InvalidError">InvalidError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.SessionError" href="#asyncauth.core.models.Session.SessionError">SessionError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.decode" href="#asyncauth.core.models.Session.decode">decode</a></code></li>
<li><code><a title="asyncauth.core.models.Session.decode_raw" href="#asyncauth.core.models.Session.decode_raw">decode_raw</a></code></li>
<li><code><a title="asyncauth.core.models.Session.encode" href="#asyncauth.core.models.Session.encode">encode</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="asyncauth.core" href="index.html">asyncauth.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="asyncauth.core.models.Account" href="#asyncauth.core.models.Account">Account</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.Account.AccountError" href="#asyncauth.core.models.Account.AccountError">AccountError</a></code></li>
<li><code><a title="asyncauth.core.models.Account.DisabledError" href="#asyncauth.core.models.Account.DisabledError">DisabledError</a></code></li>
<li><code><a title="asyncauth.core.models.Account.ErrorFactory" href="#asyncauth.core.models.Account.ErrorFactory">ErrorFactory</a></code></li>
<li><code><a title="asyncauth.core.models.Account.ExistsError" href="#asyncauth.core.models.Account.ExistsError">ExistsError</a></code></li>
<li><code><a title="asyncauth.core.models.Account.IncorrectPasswordError" href="#asyncauth.core.models.Account.IncorrectPasswordError">IncorrectPasswordError</a></code></li>
<li><code><a title="asyncauth.core.models.Account.InvalidEmailError" href="#asyncauth.core.models.Account.InvalidEmailError">InvalidEmailError</a></code></li>
<li><code><a title="asyncauth.core.models.Account.TooManyCharsError" href="#asyncauth.core.models.Account.TooManyCharsError">TooManyCharsError</a></code></li>
<li><code><a title="asyncauth.core.models.Account.UnverifiedError" href="#asyncauth.core.models.Account.UnverifiedError">UnverifiedError</a></code></li>
<li><code><a title="asyncauth.core.models.Account.get_client" href="#asyncauth.core.models.Account.get_client">get_client</a></code></li>
<li><code><a title="asyncauth.core.models.Account.json" href="#asyncauth.core.models.Account.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.AuthError" href="#asyncauth.core.models.AuthError">AuthError</a></code></h4>
</li>
<li>
<h4><code><a title="asyncauth.core.models.AuthenticationSession" href="#asyncauth.core.models.AuthenticationSession">AuthenticationSession</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.AuthenticationSession.UnknownLocationError" href="#asyncauth.core.models.AuthenticationSession.UnknownLocationError">UnknownLocationError</a></code></li>
<li><code><a title="asyncauth.core.models.AuthenticationSession.verify_location" href="#asyncauth.core.models.AuthenticationSession.verify_location">verify_location</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.BaseErrorFactory" href="#asyncauth.core.models.BaseErrorFactory">BaseErrorFactory</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.BaseErrorFactory.get" href="#asyncauth.core.models.BaseErrorFactory.get">get</a></code></li>
<li><code><a title="asyncauth.core.models.BaseErrorFactory.throw" href="#asyncauth.core.models.BaseErrorFactory.throw">throw</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.BaseModel" href="#asyncauth.core.models.BaseModel">BaseModel</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.BaseModel.DeletedError" href="#asyncauth.core.models.BaseModel.DeletedError">DeletedError</a></code></li>
<li><code><a title="asyncauth.core.models.BaseModel.Meta" href="#asyncauth.core.models.BaseModel.Meta">Meta</a></code></li>
<li><code><a title="asyncauth.core.models.BaseModel.NotFoundError" href="#asyncauth.core.models.BaseModel.NotFoundError">NotFoundError</a></code></li>
<li><code><a title="asyncauth.core.models.BaseModel.json" href="#asyncauth.core.models.BaseModel.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.CaptchaSession" href="#asyncauth.core.models.CaptchaSession">CaptchaSession</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.CaptchaSession.IncorrectCaptchaError" href="#asyncauth.core.models.CaptchaSession.IncorrectCaptchaError">IncorrectCaptchaError</a></code></li>
<li><code><a title="asyncauth.core.models.CaptchaSession.captcha_img" href="#asyncauth.core.models.CaptchaSession.captcha_img">captcha_img</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.Permission" href="#asyncauth.core.models.Permission">Permission</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.Permission.InsufficientPermissionError" href="#asyncauth.core.models.Permission.InsufficientPermissionError">InsufficientPermissionError</a></code></li>
<li><code><a title="asyncauth.core.models.Permission.json" href="#asyncauth.core.models.Permission.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.RecoverySession" href="#asyncauth.core.models.RecoverySession">RecoverySession</a></code></h4>
</li>
<li>
<h4><code><a title="asyncauth.core.models.Role" href="#asyncauth.core.models.Role">Role</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.Role.InsufficientRoleError" href="#asyncauth.core.models.Role.InsufficientRoleError">InsufficientRoleError</a></code></li>
<li><code><a title="asyncauth.core.models.Role.json" href="#asyncauth.core.models.Role.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.Session" href="#asyncauth.core.models.Session">Session</a></code></h4>
<ul class="two-column">
<li><code><a title="asyncauth.core.models.Session.DecodeError" href="#asyncauth.core.models.Session.DecodeError">DecodeError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.ErrorFactory" href="#asyncauth.core.models.Session.ErrorFactory">ErrorFactory</a></code></li>
<li><code><a title="asyncauth.core.models.Session.ExpiredError" href="#asyncauth.core.models.Session.ExpiredError">ExpiredError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.InvalidError" href="#asyncauth.core.models.Session.InvalidError">InvalidError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.Meta" href="#asyncauth.core.models.Session.Meta">Meta</a></code></li>
<li><code><a title="asyncauth.core.models.Session.SessionError" href="#asyncauth.core.models.Session.SessionError">SessionError</a></code></li>
<li><code><a title="asyncauth.core.models.Session.decode" href="#asyncauth.core.models.Session.decode">decode</a></code></li>
<li><code><a title="asyncauth.core.models.Session.decode_raw" href="#asyncauth.core.models.Session.decode_raw">decode_raw</a></code></li>
<li><code><a title="asyncauth.core.models.Session.encode" href="#asyncauth.core.models.Session.encode">encode</a></code></li>
<li><code><a title="asyncauth.core.models.Session.json" href="#asyncauth.core.models.Session.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.SessionFactory" href="#asyncauth.core.models.SessionFactory">SessionFactory</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.SessionFactory.generate_session_codes" href="#asyncauth.core.models.SessionFactory.generate_session_codes">generate_session_codes</a></code></li>
<li><code><a title="asyncauth.core.models.SessionFactory.get" href="#asyncauth.core.models.SessionFactory.get">get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asyncauth.core.models.VerificationSession" href="#asyncauth.core.models.VerificationSession">VerificationSession</a></code></h4>
<ul class="">
<li><code><a title="asyncauth.core.models.VerificationSession.VerificationCodeError" href="#asyncauth.core.models.VerificationSession.VerificationCodeError">VerificationCodeError</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>